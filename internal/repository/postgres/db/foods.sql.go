// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: foods.sql

package db

import (
	"context"
	"database/sql"

	"github.com/sqlc-dev/pqtype"
)

const countFoods = `-- name: CountFoods :one
SELECT COUNT(*) FROM foods
`

func (q *Queries) CountFoods(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countFoodsStmt, countFoods)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFood = `-- name: CreateFood :one
INSERT INTO foods (
    id,
    name,
    alternate_names,
    description,
    food_type,
    source,
    serving,
    nutrition_100g,
    ean_13,
    labels,
    package_size,
    ingredients,
    ingredient_analysis
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, name, alternate_names, description, food_type, source, serving, nutrition_100g, ean_13, labels, package_size, ingredients, ingredient_analysis, created_at, updated_at
`

type CreateFoodParams struct {
	ID                 string                `json:"id"`
	Name               string                `json:"name"`
	AlternateNames     pqtype.NullRawMessage `json:"alternate_names"`
	Description        sql.NullString        `json:"description"`
	FoodType           sql.NullString        `json:"food_type"`
	Source             pqtype.NullRawMessage `json:"source"`
	Serving            pqtype.NullRawMessage `json:"serving"`
	Nutrition100g      pqtype.NullRawMessage `json:"nutrition_100g"`
	Ean13              sql.NullString        `json:"ean_13"`
	Labels             pqtype.NullRawMessage `json:"labels"`
	PackageSize        pqtype.NullRawMessage `json:"package_size"`
	Ingredients        sql.NullString        `json:"ingredients"`
	IngredientAnalysis pqtype.NullRawMessage `json:"ingredient_analysis"`
}

func (q *Queries) CreateFood(ctx context.Context, arg CreateFoodParams) (Food, error) {
	row := q.queryRow(ctx, q.createFoodStmt, createFood,
		arg.ID,
		arg.Name,
		arg.AlternateNames,
		arg.Description,
		arg.FoodType,
		arg.Source,
		arg.Serving,
		arg.Nutrition100g,
		arg.Ean13,
		arg.Labels,
		arg.PackageSize,
		arg.Ingredients,
		arg.IngredientAnalysis,
	)
	var i Food
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AlternateNames,
		&i.Description,
		&i.FoodType,
		&i.Source,
		&i.Serving,
		&i.Nutrition100g,
		&i.Ean13,
		&i.Labels,
		&i.PackageSize,
		&i.Ingredients,
		&i.IngredientAnalysis,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFood = `-- name: DeleteFood :exec
DELETE FROM foods
WHERE id = $1
`

func (q *Queries) DeleteFood(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteFoodStmt, deleteFood, id)
	return err
}

const getFoodByEAN13 = `-- name: GetFoodByEAN13 :one
SELECT id, name, alternate_names, description, food_type, source, serving, nutrition_100g, ean_13, labels, package_size, ingredients, ingredient_analysis, created_at, updated_at FROM foods
WHERE ean_13 = $1 LIMIT 1
`

func (q *Queries) GetFoodByEAN13(ctx context.Context, ean13 sql.NullString) (Food, error) {
	row := q.queryRow(ctx, q.getFoodByEAN13Stmt, getFoodByEAN13, ean13)
	var i Food
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AlternateNames,
		&i.Description,
		&i.FoodType,
		&i.Source,
		&i.Serving,
		&i.Nutrition100g,
		&i.Ean13,
		&i.Labels,
		&i.PackageSize,
		&i.Ingredients,
		&i.IngredientAnalysis,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFoodByID = `-- name: GetFoodByID :one
SELECT id, name, alternate_names, description, food_type, source, serving, nutrition_100g, ean_13, labels, package_size, ingredients, ingredient_analysis, created_at, updated_at FROM foods
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetFoodByID(ctx context.Context, id string) (Food, error) {
	row := q.queryRow(ctx, q.getFoodByIDStmt, getFoodByID, id)
	var i Food
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AlternateNames,
		&i.Description,
		&i.FoodType,
		&i.Source,
		&i.Serving,
		&i.Nutrition100g,
		&i.Ean13,
		&i.Labels,
		&i.PackageSize,
		&i.Ingredients,
		&i.IngredientAnalysis,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listFoods = `-- name: ListFoods :many
SELECT id, name, alternate_names, description, food_type, source, serving, nutrition_100g, ean_13, labels, package_size, ingredients, ingredient_analysis, created_at, updated_at FROM foods
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListFoodsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListFoods(ctx context.Context, arg ListFoodsParams) ([]Food, error) {
	rows, err := q.query(ctx, q.listFoodsStmt, listFoods, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Food{}
	for rows.Next() {
		var i Food
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AlternateNames,
			&i.Description,
			&i.FoodType,
			&i.Source,
			&i.Serving,
			&i.Nutrition100g,
			&i.Ean13,
			&i.Labels,
			&i.PackageSize,
			&i.Ingredients,
			&i.IngredientAnalysis,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFoodsByType = `-- name: ListFoodsByType :many
SELECT id, name, alternate_names, description, food_type, source, serving, nutrition_100g, ean_13, labels, package_size, ingredients, ingredient_analysis, created_at, updated_at FROM foods
WHERE food_type = $1
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListFoodsByTypeParams struct {
	FoodType sql.NullString `json:"food_type"`
	Limit    int32          `json:"limit"`
	Offset   int32          `json:"offset"`
}

func (q *Queries) ListFoodsByType(ctx context.Context, arg ListFoodsByTypeParams) ([]Food, error) {
	rows, err := q.query(ctx, q.listFoodsByTypeStmt, listFoodsByType, arg.FoodType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Food{}
	for rows.Next() {
		var i Food
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AlternateNames,
			&i.Description,
			&i.FoodType,
			&i.Source,
			&i.Serving,
			&i.Nutrition100g,
			&i.Ean13,
			&i.Labels,
			&i.PackageSize,
			&i.Ingredients,
			&i.IngredientAnalysis,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFoodsByName = `-- name: SearchFoodsByName :many
SELECT id, name, alternate_names, description, food_type, source, serving, nutrition_100g, ean_13, labels, package_size, ingredients, ingredient_analysis, created_at, updated_at FROM foods
WHERE name ILIKE '%' || $1 || '%'
   OR EXISTS (
       SELECT 1
       FROM jsonb_array_elements_text(alternate_names) AS alt_name
       WHERE alt_name ILIKE '%' || $1 || '%'
   )
ORDER BY name
LIMIT $2 OFFSET $3
`

type SearchFoodsByNameParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchFoodsByName(ctx context.Context, arg SearchFoodsByNameParams) ([]Food, error) {
	rows, err := q.query(ctx, q.searchFoodsByNameStmt, searchFoodsByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Food{}
	for rows.Next() {
		var i Food
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AlternateNames,
			&i.Description,
			&i.FoodType,
			&i.Source,
			&i.Serving,
			&i.Nutrition100g,
			&i.Ean13,
			&i.Labels,
			&i.PackageSize,
			&i.Ingredients,
			&i.IngredientAnalysis,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
